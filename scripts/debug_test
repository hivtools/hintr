#!/usr/bin/env Rscript
library(hintr)

test_redis_available <- function() {
  available <- redux::redis_available()
  if (!available) {
    testthat::skip("Skipping test as redis is not available")
  }
  invisible(available)
}

response_from_json <- function(x) {
  jsonlite::parse_json(httr::content(x, "text", encoding = "UTF-8"))
}

free_port <- function(start, max_tries = 20) {
  force(start)
  force(max_tries)
  function() {
    port <- find_free_port(start, max_tries)
    start <<- start + 1
    port
  }
}

find_free_port <- function(start, max_tries = 20) {
  port <- seq(start, length.out = max_tries)
  for (p in port) {
    if (check_port(p)) {
      return(p)
    }
  }
  stop(sprintf("Did not find a free port between %d..%d",
               min(port), max(port)),
       call. = FALSE)
}

check_port <- function(port) {
  timeout <- 0.1
  con <- tryCatch(suppressWarnings(socketConnection(
    "localhost", port = port, timeout = timeout, open = "r")),
    error = function(e) NULL)
  if (is.null(con)) {
    return(TRUE)
  }
  close(con)
  FALSE
}

get_free_port <- free_port(9000)

hintr_server <- function(n_tries = 10, poll = 0.5) {
  test_redis_available()

  queue_id <- ids::random_id()
  port <- get_free_port()
  process <- callr::r_bg(
    function(port, queue_id) {
      hintr:::api(port)
    },
    args = list(port = port, queue_id = queue_id))
  url <- sprintf("http://localhost:%d", port)

  for (i in seq_len(n_tries)) {
    message("Attempt ", i)
    ok <- tryCatch({
      httr::stop_for_status(httr::GET(url))
      TRUE
    }, error = function(e) FALSE)
    if (ok) {
      return(list(process = process, url = url, port = port,
                  queue_id = queue_id))
    }
    if (!process$is_alive()) {
      break
    }
    Sys.sleep(poll)
  }

  message("Is API process alive?")
  message(process$is_alive())
  message("API output:")
  tryCatch(
    message(process$read_output()), error = function(e) message("FAILED: ", e$message))
  message("API error:")
  tryCatch(
    message(process$read_error()), error = function(e) message("FAILED: ", e$message))
  process$kill()
  stop("Failed to start server")
}

withr::with_dir("tests/testthat", {
  withr::with_envvar(c("USE_MOCK_MODEL" = "false"), {
    server <- hintr_server()
    ## Submit a model run
    submit <- file.path("payload", "model_submit_payload.json")
    message("PAYLOAD EXISTS")
    message(sprintf("file exists %s", file.exists(submit)))
    message("WORKING DIR")
    message(sprintf("working dir is %s", getwd()))
    message("PAYLOAD TEXT")
    message(readLines(submit))
    message("FILES IN CURRENT DIRECTORY")
    message(paste(list.files(recursive = TRUE), collapse = "\n"))
    r <- httr::POST(paste0(server$url, "/model/submit"),
                    body = httr::upload_file(submit),
                    encode = "json")
    response <- response_from_json(r)

    Sys.sleep(3)
    for (try in seq_len(10)) {
      message(sprintf("===== TRY %s =====", try))
      r <- httr::GET(paste0(server$url, "/model/status/", response$data$id))
      status_response <- response_from_json(r)
      message(status_response)

      if (!(status_response$data$status %in% c("RUNNING", "COMPLETE"))) {
        message("==== ERROR RESULT ====")
        r <- httr::GET(paste0(server$url, "/model/result/", response$data$id))
        result_response <- response_from_json(r)
        message(result_response)
        break
      }
      Sys.sleep(30)
    }
  })
})

